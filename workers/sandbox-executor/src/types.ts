/**
 * Sandbox Executor Worker Types
 * For executing Claude tasks via AI Gateway and Cloudflare Sandbox
 */

// Re-export Env from generated worker-configuration.d.ts
// The Env interface is auto-generated by `wrangler types` and includes:
// - Sandbox: DurableObjectNamespace<Sandbox>
// - CONFIG_SERVICE_URL: string
// - MAX_EXECUTION_TIME: string
// Additional properties not in wrangler.toml need to be declared here

// Extend the generated Env with additional optional bindings
// Note: ANTHROPIC_API_KEY, GITHUB_PAT, etc. are defined in worker-configuration.d.ts
// via `wrangler types` based on configured secrets
export interface Env extends Cloudflare.Env {
  // AI Gateway auth token (for SDK mode) - optional, only needed for /execute/sdk
  CF_AIG_TOKEN?: string;

  // Claude OAuth credentials JSON (for using Claude.ai Max subscription)
  // This should be the full contents of ~/.claude/.credentials.json
  CLAUDE_OAUTH_CREDENTIALS?: string;

  // On-prem Claude runner URL (via Cloudflare Tunnel)
  // When set, /execute requests are delegated to this runner
  // Falls back to sandbox execution if runner is unreachable
  CLAUDE_RUNNER_URL?: string;

  // Secret for authenticating with the on-prem Claude runner
  RUNNER_SECRET?: string;

  // On-prem Gemini runner URL (via Cloudflare Tunnel)
  // When set with executor_type: 'gemini', requests are delegated to this runner
  GEMINI_RUNNER_URL?: string;

  // Secret for authenticating with the on-prem Gemini runner
  GEMINI_RUNNER_SECRET?: string;

  // Internal API key for config-service calls (OAuth refresh, events)
  INTERNAL_API_KEY?: string;

  // Optional: Instance ID override
  DEFAULT_INSTANCE_ID?: string;

  // Optional: Rate Limiter Durable Object (for Phase 2)
  // RATE_LIMITER?: DurableObjectNamespace;
}

/**
 * Request to execute a task in the sandbox (CLI mode)
 */
export interface ExecuteRequest {
  // The task/prompt to send to the AI agent
  task: string;

  // Executor type: 'claude' (default) or 'gemini'
  // Determines which on-prem runner to use
  executor_type?: 'claude' | 'gemini';

  // Optional: Git repository to clone and work on
  repo?: string;

  // Optional: Branch to work on (creates if doesn't exist)
  branch?: string;

  // Optional: Commit message for changes (if not provided, uses auto-generated message)
  commit_message?: string;

  // Optional: Instance ID for multi-tenant scenarios
  instance_id?: string;

  // Optional: Project ID for tracking
  project_id?: string;

  // Optional: Execution options
  options?: ExecuteOptions;
}

/**
 * Options for task execution (Sandbox/CLI approach)
 */
export interface ExecuteOptions {
  // Maximum execution time in ms (default: 300000 = 5 min)
  timeout_ms?: number;

  // Whether to return git diff (only applicable if repo is provided)
  include_diff?: boolean;

  // Custom system prompt to append
  system_prompt?: string;

  // Permission mode for Claude Code
  permission_mode?: 'acceptEdits' | 'full' | 'restricted';

  // Working directory within the sandbox
  working_dir?: string;
}

/**
 * Request for SDK-based execution via AI Gateway
 */
export interface SDKExecuteRequest {
  // The prompt to send to Claude
  prompt: string;

  // Optional: Instance ID for multi-tenant scenarios
  instance_id?: string;

  // Optional: Project ID for tracking
  project_id?: string;

  // Optional: Execution options
  options?: SDKExecuteOptions;
}

/**
 * Options for SDK-based execution via AI Gateway
 */
export interface SDKExecuteOptions {
  // Maximum tokens in response (default: 1024)
  max_tokens?: number;

  // Model to use (default: 'sonnet')
  // Can be shorthand: 'opus', 'sonnet', 'haiku'
  // Or full model ID: 'claude-sonnet-4-20250514'
  model?: string;

  // Custom system prompt
  system_prompt?: string;
}

/**
 * Response from SDK-based execution via AI Gateway
 */
export interface SDKExecuteResponse {
  success: boolean;
  request_id: string;
  timestamp: string;

  // The result text from Claude
  result?: string;

  // Execution metadata
  metadata?: {
    execution_time_ms: number;
    model?: string;
    usage?: {
      input_tokens: number;
      output_tokens: number;
    };
    stop_reason?: string | null;
  };
}

/**
 * Response from sandbox/CLI task execution
 */
export interface ExecuteResponse {
  success: boolean;
  request_id: string;
  timestamp: string;

  // Execution output
  logs?: string;
  diff?: string;
  result?: string;

  // Execution metadata
  metadata?: {
    execution_time_ms: number;
    sandbox_id: string;
    repo?: string;
    repo_created?: boolean;
    branch?: string;
    commit_sha?: string;
    commit_url?: string;
    pushed?: boolean;
    using_oauth?: boolean;
  };
}

/**
 * Result of git commit/push operation
 */
export interface GitCommitResult {
  success: boolean;
  sha?: string;
  branch?: string;
  error?: string;
}

/**
 * Error response format
 */
export interface ErrorResponse {
  error: string;
  error_code: string;
  request_id: string;
  details?: Record<string, unknown>;
}

/**
 * Health check response
 */
export interface HealthResponse {
  status: 'healthy' | 'degraded' | 'unhealthy';
  service: string;
  timestamp: string;
  version?: string;
}

/**
 * Command execution result from sandbox
 */
export interface CommandResult {
  success: boolean;
  stdout: string;
  stderr: string;
  exitCode?: number;
}

/**
 * Options for creating a new GitHub repository
 */
export interface CreateRepoOptions {
  description?: string;
  private?: boolean;
  autoInit?: boolean;
}
